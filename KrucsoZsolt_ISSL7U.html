<!DOCTYPE html>
<html lang="hu">

<head>
  <meta charset=utf-8>
  <title>Three.js Hello app</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { width: 100%; height: 100% }
    .top-right-btn {
      position: relative;
      z-index: 1000;
      padding: 6px 10px;
      background: #222;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      opacity: 0.95;
      font-family: sans-serif;
      font-size: 13px;
    }
    .top-right-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      z-index: 1000;
    }
    /* New: top-left sample text */
    .top-left-text {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      color: #fff;
      font-family: sans-serif;
      font-size: 14px;
      background: rgba(0,0,0,0.25);
      padding: 6px 8px;
      border-radius: 4px;
      pointer-events: none;
    }
  </style>
</head>

<body>

<script type="importmap">
  {
      "imports": {
          "three": "./js-r178/build/three.module.js",
          "TrackballControls": "./js-r178/examples/jsm/controls/TrackballControls.js"
      }
  }
</script>

<script type="module">
  import * as THREE from 'three';
  import { TrackballControls } from 'TrackballControls';

  // Globális változók
  let WIDTH, HEIGHT, aspectRatio;
  let renderer;
  let scene, camera;
  let controls;
  let directionalLight;
  let textureLoader = new THREE.TextureLoader();

  // New sun-cycle related state
  let directionalOn = true; // toggles visibility
  let sunCycleStartTime = performance.now();
  const sunCycleDurationMs = 60 * 1000; // 6 minutes
  const sunRadius = 20; // distance from scene center in x-z plane
  let sunY = 100; // keep y constant (match initial light.y)

  init();

  // Csak egyszeri állókép rajzolása
  // render();

  // Animáció indítása
  animate();

  function init() {
    // Böngésző ablakméret lekérése és méretarány számítása
    HEIGHT = window.innerHeight;
    WIDTH = window.innerWidth;
    aspectRatio = WIDTH / HEIGHT;

    // Renderer létrehozása és DOM-hoz adása
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setSize( WIDTH, HEIGHT );
    renderer.setClearColor( 0x000000 );
    document.body.appendChild( renderer.domElement );

    // Színtér létrehozása
    scene = new THREE.Scene();

    //Színtér tárgyak
    let treeTrunkTexture = textureLoader.load( 'tree_trunk.jpg' );
    let treeLeafTexture = textureLoader.load( 'leaf.jpg' );
    const createTree = (x, z, scale) => {
      const g = new THREE.Group();
      const trunkG = new THREE.CylinderGeometry( 0.5 * scale, 1 * scale, 3 * scale, 8 );
      const trunkM = new THREE.MeshPhongMaterial();
      trunkM.map = treeTrunkTexture;
      const trunk = new THREE.Mesh( trunkG, trunkM );
      trunk.position.y = 4 * scale;
      trunk.scale.set(2 * scale, 3 * scale, 2 * scale);

      const crownG = new THREE.SphereGeometry( 3 * scale, 16, 16 );
      const crownM = new THREE.MeshPhongMaterial();
      crownM.map = treeLeafTexture;
      const crown = new THREE.Mesh( crownG, crownM );
      crown.position.y = 8 * scale;
      crown.scale.y = -0.7;

      g.add( crown );
      g.add( trunk );
      g.position.x = x;
      g.position.z = z;
      scene.add( g );
      return g;
    };

    createTree( -20, -20, 0.8 );
    createTree( 16, -20, 1.1 );
    createTree( 20, 20, 1.3 );
    createTree( -13, 18, 0.9 );
    createTree( 13, 18, 0.9 );
    createTree( -15, -18, 1.3 );
    createTree( 10, -5, 1.1 );
    createTree( -16, -2, 1.1 );
    createTree( 3, 13, 0.9 );
    createTree( 20, 2, 0.8 );

    const createBush = (x, z, scale) => {
      const g = new THREE.Group();
      const bushG = new THREE.SphereGeometry( 1 * scale, 8, 8 );
      const bushM = new THREE.MeshPhongMaterial( { color: 0x00AA00 } );
      const bush1 = new THREE.Mesh( bushG, bushM );
      const bush2 = new THREE.Mesh( bushG, bushM );
      const bush3 = new THREE.Mesh( bushG, bushM );
      bush1.scale.set( scale, scale, scale );
      g.add(bush1);
      bush2.position.x = 0.5 * scale;
      bush2.position.z = -0.5 * scale;
      g.add(bush2);
      bush3.position.x = 0.5 * scale;
      bush3.position.z = 0.5 * scale;
      g.add(bush3);
      g.position.x = x;
      g.position.z = z;
      g.rotateY( Math.random() * Math.PI * 2 );
      scene.add( g );
      return g;
    };

    createBush( -5, -10, 1 );
    createBush( 8, 12, 0.8 );
    createBush( -12, 5, 1.2 );
    createBush( 0, -15, 1 );
    createBush( 15, 5, 0.9 );
    createBush( 12, -8, 1.2 );

    let rockTexture = textureLoader.load( 'rock.png' );
    const createRock = (x, z, scale) => {
      const rockG = new THREE.DodecahedronGeometry( 1 * scale, 0 );
      const rockM = new THREE.MeshPhongMaterial();
        rockM.map = rockTexture;
      const rock = new THREE.Mesh( rockG, rockM );
      rock.position.x = x;
      rock.position.z = z;
      rock.scale.set( scale, scale, scale );
      rock.rotation.x = Math.random() * Math.PI;
      rock.rotation.y = Math.random() * Math.PI;
      rock.rotation.z = Math.random() * Math.PI;
      scene.add( rock );
      return rock;
    };

    createRock( -10, -15, 1.2 );
    createRock( 10, 15, 1.1 );
    createRock( -10, 15, 1 );
    createRock( 10, -15, 0.9 );
    createRock( -13, -12, 0.8 );

    let talajG = new THREE.PlaneGeometry( 20, 20, 10, 10 );
    let talajM = new THREE.MeshLambertMaterial( { color: 0x00FF00, wireframe: false } );
    let talaj = new THREE.Mesh( talajG, talajM );
    talaj.rotation.x = - Math.PI / 2;
    talaj.scale.x = 3;
    talaj.scale.y = 3;

    scene.add( talaj );
    // Színtér tárgyak

    directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(5, 10, 7.5);
    scene.add( directionalLight );

    sunY = directionalLight.position.y;

    let ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    let ambientOn = true;
    scene.add( ambientLight );

    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'top-right-controls';

    const ambientBtn = document.createElement('button');
    ambientBtn.className = 'top-right-btn';
    ambientBtn.textContent = 'Ambient: On';
    ambientBtn.addEventListener('click', () => {
      ambientOn = !ambientOn;
      ambientLight.visible = ambientOn;
      ambientBtn.textContent = ambientOn ? 'Ambient: On' : 'Ambient: Off';
    });
    controlsDiv.appendChild( ambientBtn );

    // Add Sun on/off button
    const sunBtn = document.createElement('button');
    sunBtn.className = 'top-right-btn';
    sunBtn.textContent = 'Sun: On';
    sunBtn.addEventListener('click', () => {
      directionalOn = !directionalOn;
      directionalLight.visible = directionalOn;
      sunBtn.textContent = directionalOn ? 'Sun: On' : 'Sun: Off';
    });
    controlsDiv.appendChild( sunBtn );

    let axesHelper = new THREE.AxesHelper( 10 );
    scene.add( axesHelper );
    let axesOn = true;
    const axesBtn = document.createElement('button');
    axesBtn.className = 'top-right-btn';
    axesBtn.textContent = 'Axes: On';
    axesBtn.addEventListener('click', () => {
      axesOn = !axesOn;
      if (axesHelper) axesHelper.visible = axesOn;
      axesBtn.textContent = axesOn ? 'Axes: On' : 'Axes: Off';
    });
    controlsDiv.appendChild( axesBtn );

    document.body.appendChild( controlsDiv );

    const sampleText = document.createElement('div');
    sampleText.className = 'top-left-text';
    sampleText.textContent = 'Krucsó Zsolt | ISSL7U | programtervező informatikus | 2025/26/1 félév';
    document.body.appendChild(sampleText);

    camera = new THREE.PerspectiveCamera( 75, aspectRatio, 0.1, 1000 );
    camera.position.z = 15;
    camera.lookAt( scene.position );

    controls = new TrackballControls( camera, renderer.domElement );
    controls.rotateSpeed = 5.0;
    controls.panSpeed = 1.0;

    window.addEventListener( 'resize', handleWindowResize, false );
  }

  function handleWindowResize() {
    HEIGHT = window.innerHeight;
    WIDTH = window.innerWidth;
    console.log( 'WIDTH=' + WIDTH + '; HEIGHT=' + HEIGHT );
    renderer.setSize( WIDTH, HEIGHT );
    aspectRatio = WIDTH / HEIGHT;
    camera.aspect = aspectRatio;
    camera.updateProjectionMatrix();
    render();
  }

  function animate() {
    requestAnimationFrame( animate );
    controls.update();
    render();
  }

  function updateSun() {
    const now = performance.now();
    const elapsed = (now - sunCycleStartTime) % sunCycleDurationMs;
    const t = elapsed / sunCycleDurationMs;

    const angle = t * Math.PI * 2;

    const x = sunRadius * Math.cos(angle);
    const z = sunRadius * Math.sin(angle);
    directionalLight.position.x = x;
    directionalLight.position.z = z;
    directionalLight.position.y = sunY;

    const intensity = 0 + 1 * Math.sin(Math.PI * t);
    directionalLight.intensity = intensity;
  }

  function render() {
    updateSun();
    renderer.render( scene, camera );
  }

</script>
</body>
</html>
